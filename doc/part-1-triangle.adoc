:hidecomments:

First, let's begin our main function and create an event loop:

[source,rust]
----
tag::main_start[]
ifndef::hidecomments[]
// TODO: Reorder declarations so that they're as close to their usage sites as they can be
// TODO: Try to create the window with a LogicalSize directly - without screwing
//  up swapchain dimensions.
// TODO: Look at the error types for every `expect` to set a good message.
endif::hidecomments[]
fn main() {
    use gfx_hal::{device::Device, window::Surface, Instance as _};

    const APP_NAME: &'static str = "Part 1: Drawing a triangle";
    const WINDOW_SIZE: [u32; 2] = [256, 256];

    let event_loop = winit::event_loop::EventLoop::new();
end::main_start[]

    ...
}
----

You'll notice we also imported a few traits from the `gfx_hal` crate. In general, throughout this tutorial I'll try to keep imports close to where they are used. The three traits above are used in many places, however.

We defined a constant for the `WINDOW_SIZE` above, but before we can actually create a window, there's some subtleties to address when it comes to resolution. Blah blah blah, so we need both a _logical size_ and a _physical size_.

[source,rust]
----
tag::window_size[]
    let (logical_window_size, physical_window_size) = {
        use winit::dpi::{LogicalSize, PhysicalSize};

        let dpi = event_loop.primary_monitor().scale_factor();
        let logical: LogicalSize<u32> = WINDOW_SIZE.into();
        let physical: PhysicalSize<u32> = logical.to_physical(dpi);

        (logical, physical)
    };
end::window_size[]
----

The _physical size_ is what we're concerned with when it comes to rendering, as we want our rendering surface to represent every pixel. So let's define that now:

[source,rust]
----
tag::surface_extent[]
    use gfx_hal::window::Extent2D;
    let mut surface_extent = Extent2D {
        width: physical_window_size.width,
        height: physical_window_size.height,
    };
end::surface_extent[]
----

Make the window:

[source,rust]
----
tag::window[]
    let window = winit::window::WindowBuilder::new()
        .with_title(APP_NAME)
        .with_inner_size(logical_window_size)
        .build(&event_loop)
        .expect("TODO");
end::window[]
----

Before we do any graphics, let's jump ahead and set up our main event loop:

[source,rust]
----
tag::event_loop_start[]
    let mut should_rebuild_swapchain = true;

    event_loop.run(move |event, _, control_flow| {
        use winit::event::{Event, WindowEvent};
        use winit::event_loop::ControlFlow;

        match event {
            Event::WindowEvent { event, .. } => match event {
                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit,
                WindowEvent::Resized(dims) => {
                    surface_extent = Extent2D {
                        width: dims.width,
                        height: dims.height,
                    };
                    should_rebuild_swapchain = true;

                }
                WindowEvent::ScaleFactorChanged { new_inner_size, .. } => {
                    surface_extent = Extent2D {
                        width: new_inner_size.width,
                        height: new_inner_size.height,
                    };
                    should_rebuild_swapchain = true;
                }
                _ => (),
            },
            Event::MainEventsCleared => window.request_redraw(),
            Event::RedrawRequested(_) => {
end::event_loop_start[]
                ...
tag::event_loop_end[]
            }
            _ => (),
        }
    });
end::event_loop_end[]
----

Here's what all that does: responding to close, resize, and driving draw loop.

Now you should be able to run it and see an empty window. I hope you enjoy that, because it's all you're going to see until the very last moment of this tutorial. It's a good idea to run the program after each change though, just to make sure there are no crashes.

So now we have a window. If we want to be able to draw a triangle, we're going to have to talk to the GPU.

[source,rust]
----
tag::instance[]
    let (instance, surface, adapter) = {
        let instance = backend::Instance::create(APP_NAME, 1).expect("TODO");
        let surface = unsafe { instance.create_surface(&window).expect("TODO") };
        let adapter = instance.enumerate_adapters().remove(0);

        (instance, surface, adapter)
    };
end::instance[]
----

[source,rust]
----
tag::device[]
    let (device, mut queue_group) = {
        use gfx_hal::queue::QueueFamily;

        let queue_family = adapter
            .queue_families
            .iter()
            .find(|family| {
                surface.supports_queue_family(family) && family.queue_type().supports_graphics()
            })
            .expect("TODO");

        let mut gpu = unsafe {
            use gfx_hal::adapter::PhysicalDevice;

            adapter
                .physical_device
                .open(&[(queue_family, &[1.0])], gfx_hal::Features::empty())
                .expect("TODO")
        };

        (gpu.device, gpu.queue_groups.pop().expect("TODO"))
    };
end::device[]
----

[source,rust]
----
tag::command_pool[]
    let mut command_pool = unsafe {
        use gfx_hal::pool::CommandPoolCreateFlags;

        device
            .create_command_pool(queue_group.family, CommandPoolCreateFlags::empty())
            .expect("TODO")
    };
end::command_pool[]
----


[source,rust]
----
tag::surface_color_format[]
    let surface_color_format = {
        use gfx_hal::format::{ChannelType, Format};

        let supported_formats = surface.supported_formats(&adapter.physical_device);
        supported_formats.map_or(Format::Rgba8Srgb, |formats| {
            formats
                .iter()
                .find(|format| format.base_format().1 == ChannelType::Srgb)
                .map(|format| *format)
                .unwrap_or(formats[0])
        })
    };
end::surface_color_format[]
----

[source,rust]
----
tag::render_pass[]
    let render_pass = {
        use gfx_hal::image::Layout;
        use gfx_hal::pass::{
            Attachment, AttachmentLoadOp, AttachmentOps, AttachmentStoreOp, SubpassDesc,
        };

        let color_attachment = Attachment {
            format: Some(surface_color_format),
            samples: 1,
            ops: AttachmentOps::new(AttachmentLoadOp::Clear, AttachmentStoreOp::Store),
            stencil_ops: AttachmentOps::DONT_CARE,
            layouts: Layout::Undefined..Layout::Present,
        };

        let subpass = SubpassDesc {
            colors: &[(0, Layout::ColorAttachmentOptimal)],
            depth_stencil: None,
            inputs: &[],
            resolves: &[],
            preserves: &[],
        };

        unsafe {
            device
                .create_render_pass(&[color_attachment], &[subpass], &[])
                .expect("TODO")
        }
    };
end::render_pass[]
----

